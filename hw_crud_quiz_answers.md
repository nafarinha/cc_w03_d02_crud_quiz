# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

>Q1. Where are we instantiating instances of the Property class?

In the console.rb file on `var = Property.new()`.

>Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

In the method `save()` available in the property.rb file.

>Q3. In console.rb, which lines modify the database?

Ln 4 `Property.delete_all()`<br>
Ln 13 `property1.save()`<br>
Ln 22 `property2.save()`<br>
Ln 31 `property3.save()`<br>
Ln 33 `property1.delete()`<br>

>Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

Because the id field in the table is a primary key and managed automatically by the database, we want the value assigned to `@id` to originate from the db table and not from our ruby program. Otherwise it would not be possible to uniquely identify the table records returned to our program.

>Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?

After `RETURNING` the id value generated by the database when the INSERT clause is executed, in line 32, the PG::Result object returns the value stored on tuple `0` and field `id` and gets assigned into the instance variable `@id`. Because the `save()` is an instance method and will be called on a single object, the PG:Result return will always have a single tuple, hence will always be tuple *n*=0.

>Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?

The guard will evaluate if `options['id']` is `true` or `false`, and if true, it will initialize the `@id` instance variable and be assigned to the the key `id` corresponding value of the hash in `options`.  Everything in Ruby is truthy except `nil` and `false`. Hence `options['id']` would evaluate to true. But `options['id']` is only truthy when it exists and this only happens after we run the `save()` instance method. When we initialize a new Property object, `id` does not yet exist, hence `options['id']` evaluates to false and consequently the instance variable `@id` is not initialized.

>Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?

Instance methods apply only to an instance of the class while class methods provide functionality to the whole class.<br>
We would use the former when the method's functionality is meant to be used only by the instantiated object (e.g. instance method `save()` inserts the instantiated object values into the database table) and the latter to provide functionality to the whole class and consequently its instantiated objects (e.g. the `self.find(id)` will find any of tuples in the db table which field `id` is equal to the method's argument).

>Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?

Both `db.exec()` and `db.exec_prepared()` will return a Result object, provided by the PG gem, similar to the following example:<br>
```#<PG::Result:0x007f9706112ea8 status=PGRES_TUPLES_OK ntuples=8 nfields=5 cmd_tuples=8>```<br>

To be able to use the returned data in a meaningful way in a ruby program, we use the PG::Result class public instance method that returns tuple *n* as a hash (e.g. `result[0] → Hash`) that can then be passed to the map method from the Enumerable mixin to instantiate a new Property custom object for each hash returned by the PG::Result above-mentioned method.


>Q9. Why do we use prepared statements when performing database operations?

Prepared statements offer the ability to optimize performance. They allow to separate the code from the data, by first sending the former (e.g. `.prepare()`) to the db server, taking placeholders/bind parameters instead of the data, and a second request will send the actual data (e.g. `.exec_prepared()`). Besides performance benefits, they also prevent SQL injection attacks.

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the Property class.

>Q10. What do they take in as their arguments?

The two methods take a string as argument that then is passed on to the query statement as a search condition to the `WHERE` clause. The query will return all rows of the table where the result of the condition is true.

>Q11. What are their return values?

Their return values, stored in local variable `found_property`, are an instantiated object of the Property class, that in turn, takes `property_hash` as argument. `property_hash` is the tuple *n*=0 returned as a hash of the PG::Result instantiated object `results_array`.
